% !TeX root = ./PhDThesis.tex

\chapter{Stable trapping of multiple ions}

For a newly built cryogenic trap system, the experimental implementation of stable trapping of multiple ions may take most of the project time before some quantum computing or quantum simulation experiments can be carried out. Experimental implementation of stable trapping of multiple ions involves not only achieving long-lived ion crystals, but also testing a stable standard experimental flow, debugging the experimental platform for various sources of noise, and developing an automatic experimental control system. From a project perspective, it is also a good idea to iterate and optimise the system while achieving stable trapping of multiple ions, and then try to solve the problem when the experiment gets stuck somewhere. Personally, I think more attention should be paid to experimental implementation of stable trapping of multiple ions, because for complex systems, the duplication of effort involved in finding a problem and then solving it can make the total time spent more than the time spent on building a stable experimental system in advance. However, the experimental implementation of stable trapping of multiple ions may not be well defined, and this may become a hole in the methodology.



\section{Semi-automatic experimental control system}

We usually divide the experimental tasks into daily operation tasks and current experiment tasks. The boundary between the two is not clear and we add some daily operation tasks by summarising some of the experimental tasks that have already been solved. Daily operation tasks can also be called experimental setup's parameters calibration tasks. For cryogenic trap systems, daily operation tasks also include the long-term monitoring of some system parameters. In an ideal laboratory environment it is possible to implement an automatic experimental control system, but in most laboratories we can only strive for a semi-automatic experimental control system. This is because some key points have to be controlled and checked by humans, mainly from some uncontrollable human disturbances.

Semi-automatic experimental control system mainly refers to the software system, which contains the front-end system, the back-end system, the database system and the experimental workflow.

The front-end system is the graphical interface that enables the experimenter to conduct experiments. The popular front-end technologies are client-side front-end technology and Web front-end technology. The more commonly used client-side front-end software in the laboratory are Labview, Mathematica, Matlab and other commercial software, which have rich functions and a friendly programming environment. I have written client-side front-end software based on python and pyqt5, as well as web front-end based on HTML5 technology in the course of my experiments. We can start building the experimental platform without focusing too much on front-end development, as these technologies are not necessary for physics research, and front-end technologies are rapidly growing, so it is possible to leave the front-end system to the professionals.

The back-end system is one of the core elements of the semi-automatic experimental control system. A unified back-end system will speed up the development of the entire semi-automatic experimental control system and facilitate communication and cooperation between project team members. We need the back-end system to control the experimental apparatus in a stable manner and in accordance with the experimental targets. There are a very large number of programming languages for developing back-end systems, suitable for use in the laboratory are C, python, etc. We can also consider using software that integrates front and back ends such as Labview, Mathematica, Matlab, etc. A good back-end system must adhere to lab safety rules, have a good logging system, have a good working state set, be stable over time and have a fast response time. If you are working with multiple people you need to consider version control and documentation for development, such as code hosting. Long-term stability requires a good architecture, as instrument switches and new instrument additions occur frequently and the back-end system should not be offline too often. Instrument control protocols based on sockets and SCPI commands, mqtt protocol based instrument control protocols etc. can be considered. Fast response requires that the back-end program should have a response time of no more than 10-50 ms, which should be met in order to be able to perform complex operations.

The database system has to take on the task of not only storing data but also taking into account data security. The database system on the experiment should take into account versatility and scalability, and should meet the needs of experimenters of different programming levels to use it. In addition to using SQL databases, InfluxDB, etc., it is also possible to use direct forms of experimental logs and file directory management, or even to use software such as excel directly for recording and management. In short, the database system should be compatible and easy to use as long as it exists and is standardised.

The experimental workflow does not primarily involve work on the code side of things. It is more like a framework bringing together the front-end system, the back-end system and the database system. We need to think about how to easily present the database and access historical data in the front-end system. We need to use it to log, deliver and present the results of experiments. We need to design daily operations and current experiments and easily code the corresponding tasks. Using Mathmatica's notebook or using something like IPython based Jypyter will allow us to do this very well.

During the early build of the lab, we should implement scripted, semi-automated tests under the command of an experimental workflow as soon as possible. With this layout, instead of focusing on front-end system development, we can focus on experimental workflow and database system refinement, while the back-end system can be updated with versioning to patch bugs and improve performance.
